iOS Application Technical Specification: Travel Time Tracker App v1.0Version: 1.1Date: 2025-04-15 (Updated)1. OverviewThis document outlines the technical specifications for the iOS client application (v1.1) of the Travel Time Tracker. The app allows users to track time spent in different countries, primarily for visa compliance (initially Schengen 90/180 rule). It interacts with a Python backend via a REST API for data storage, synchronization, and calculations.This version focuses on user authentication, manual data entry, CSV import initiation, displaying travel data and calculations, receiving notifications, and offline support.2. Target Platform & TechnologyPlatform: iOSMinimum iOS Version: iOS 15+Language: SwiftArchitecture: MVVM (Model-View-ViewModel). Data flow primarily using Swift's native async/await.UI: SwiftUI. Native components.Networking: Alamofire library for API communication.Persistence: Realm Swift SDK for local caching and offline storage.Dependencies: Swift Package Manager (SPM).3. Core Features & Responsibilities(Remains the same as previous spec version)User Interface implementation.Authentication handling (Sign in with Apple, Email/Pass).API Interaction via Alamofire.Data Handling & Sync using Realm.Manual Entry implementation.CSV Import initiation and status polling.Displaying Data in SwiftUI views.Notification handling.4. iOS Application SpecificationUI/UX:Adhere to Apple's Human Interface Guidelines (HIG).Focus on clarity, ease of use. Detailed wireframes/mockups TBD.Views (SwiftUI):LoginView: Handles email/pass and Apple Sign-In button.RegistrationView: Handles email/pass signup.TravelListView: Displays TravelSegment data chronologically in a List, likely using Realm's SwiftUI property wrappers (e.g., @ObservedResults).TravelCalendarView: Uses a third-party SwiftUI calendar library (e.g., FSCalendar wrapper, ElegantCalendarView, or similar - TBD by dev team) to highlight travel days.TravelMapView: Uses MapKit integrated with SwiftUI. Highlights visited countries. Tapping a country annotation could show total time spent, or color intensity could represent time spent.DashboardView: Displays summary information (current location guess, Schengen status).ManualEntryView: Form for adding/editing TravelSegment. Uses pickers.SettingsView: Includes logout, potentially future settings.Authentication Flow:On launch, check Keychain for valid access and refresh tokens.If valid access token exists, proceed. If expired but refresh token valid, attempt refresh via API.If no valid tokens, present LoginView.Implement API calls to /api/auth/... endpoints using Alamofire. Store tokens securely in Keychain upon successful login/registration. Clear tokens on logout. Manage app state via @EnvironmentObject or similar.Networking Layer:Create a dedicated service/manager class (e.g., APIService) using Alamofire and Swift's async/await for handling API communication.Define request/response models (Codable structs) matching the API specification.Implement robust error handling for Alamofire responses and API errors.Persistence Layer:Use Realm Swift SDK. Define Realm Object subclasses mirroring the API data models (User, Country, TravelSegment).Implement functions to write data fetched from API into Realm, fetch data for UI using Realm's query capabilities and SwiftUI property wrappers (e.g., @ObservedRealmObject, @ObservedResults).Synchronization Logic:Strategy: Fetch-then-update.When app becomes active or network connectivity is restored:Check for local changes (new/modified Realm objects not yet synced) and upload them to the backend via API calls.Fetch latest data from backend API endpoints (potentially using If-Modified-Since headers if backend supports it).Compare fetched data with local Realm data using updated_at timestamps. Update Realm objects with newer data from the backend.Conflict Handling: Implement "Last Write Wins". If local data has a newer updated_at timestamp than fetched data (unlikely if sync logic is correct, but possible), the local change takes precedence during upload. If fetched data is newer, it overwrites local data.CSV Import Implementation:Present the .fileImporter view modifier.On selection, get file URL.Initiate background upload task using Alamofire to send the file data to /api/travel-segments/import/csv/.Receive task_id from the response.Show progress/activity indicator. Periodically poll the /api/travel-segments/import/status/{task_id}/ endpoint using Alamofire until status is Success/Failure. Update UI accordingly.Calculations Display:Fetch Schengen status periodically or on demand from /api/calculations/schengen/ using Alamofire.Update relevant @State or @ObservedObject properties in the DashboardView's ViewModel/View, causing the SwiftUI view to update.Notifications Implementation:Use UserNotifications framework.Request authorization.Register for remote notifications and handle token registration/updates via AppDelegate methods or equivalent SwiftUI lifecycle integration. Send device token to backend.Handle incoming push notifications.5. Data Models (Client Representation)Client-side models will be Realm Object subclasses, mirroring the structure of the JSON data models defined in the Backend Specification, leveraging Codable where appropriate for API interaction before Realm conversion.User (Realm Object)Country (Realm Object)TravelSegment (Realm Object)SchengenStatus (Likely a simple Codable struct, as it's fetched on demand, not necessarily persisted long-term unless needed for offline display).6. Assumptions & Future ConsiderationsBackend Availability: Assumes a functional backend API according to the Backend Specification.Detailed UX/UI: Requires separate design artifacts.Third-Party Libraries: Requires selection and integration of a calendar library, Realm Swift SDK, and Alamofire via SPM.App Store Submission: Standard requirements apply.Refresh Token Handling: Secure storage in Keychain and implementation of refresh logic in the networking layer are crucial.